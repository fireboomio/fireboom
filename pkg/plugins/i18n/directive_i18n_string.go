// Code generated by "i18n-stringer -type Directive -tomlpath directive -defaultlocale zh_cn"; DO NOT EDIT.

package i18n

import (
	"context"
	"fmt"
	"strconv"
)

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the i18n-stringer command to generate them again.
	var x [1]struct{}
	_ = x[ExportDesc-0]
	_ = x[FormatDateTimeDesc-10101]
	_ = x[FormatDateTimeArgFormatDesc-10102]
	_ = x[FormatDateTimeArgCustomFormatDesc-10103]
	_ = x[FromClaimDesc-10201]
	_ = x[FromClaimArgNameDesc-10202]
	_ = x[FromClaimArgCustomJsonPathDesc-10203]
	_ = x[FromHeaderDesc-10301]
	_ = x[InjectCurrentDateTimeDesc-0]
	_ = x[InjectEnvironmentVariableDesc-0]
	_ = x[InjectGeneratedUUIDDesc-0]
	_ = x[InternalDesc-10401]
	_ = x[InternalOperationDesc-10501]
	_ = x[JsonschemaDesc-10601]
	_ = x[JsonschemaArgMinimumDesc-10602]
	_ = x[JsonschemaArgMaximumDesc-10603]
	_ = x[JsonschemaArgMinItemsDesc-10604]
	_ = x[JsonschemaArgMaxItemsDesc-10605]
	_ = x[JsonschemaArgUniqueItemsDesc-10606]
	_ = x[JsonschemaArgMaxLengthDesc-10607]
	_ = x[JsonschemaArgMinLengthDesc-10608]
	_ = x[JsonschemaArgPatternDesc-10609]
	_ = x[JsonschemaArgCommonPatternDesc-10610]
	_ = x[RbacDesc-10701]
	_ = x[RbacRequireMatchAnyDesc-10702]
	_ = x[RbacRequireMatchAllDesc-10703]
	_ = x[RbacDenyMatchAllDesc-10704]
	_ = x[RbacDenyMatchAnyDesc-10705]
	_ = x[TransactionDesc-10801]
	_ = x[TransactionArgMaxWaitSecondsDesc-10802]
	_ = x[TransactionArgTimeoutSecondsDesc-10803]
	_ = x[TransactionArgIsolationLevelDesc-10804]
	_ = x[TransformDesc-10901]
	_ = x[TransformArgGetDesc-10902]
	_ = x[WhereInputDesc-11001]
	_ = x[WhereInputFieldNotDesc-11002]
	_ = x[WhereInputFieldFilterDesc-11003]
	_ = x[WhereInputFilterFieldFieldDesc-11004]
	_ = x[WhereInputFilterFieldScalarDesc-11005]
	_ = x[WhereInputFilterFieldRelationDesc-11006]
	_ = x[WhereInputFilterCommonFieldTypeDesc-11007]
	_ = x[WhereInputScalarFilterFieldInsensitiveDesc-11008]
	_ = x[WhereInputRelationFilterFieldWhereDesc-11009]
	_ = x[InjectRuleValueDesc-11101]
	_ = x[DisallowParallelDesc-11201]
	_ = x[CustomizedFieldDesc-11301]
	_ = x[SkipVariableDesc-11401]
	_ = x[AsyncResolveDesc-11501]
	_ = x[FirstRawResultDesc-11601]
}

const (
	_Directive_ZhCn_name = "作用于标量选择集上，将字段赋值给@internal声明的变量作用在字段上，用于格式化日期枚举值，系统内置的标准格式，如 ISO8601自定义格式，需遵循Golang规范，例如 2006-01-02 15:04:05作用于变量上，用于注入用户信息用于String变量，注入OIDC Claim对象声明的值，如USERID等用于任意变量，name=CUSTOM时生效，以数组形式指定json path，从CustomClaims中提取数据作用于String变量上，用于注入请求头中的字段作用于变量上，用于声明变量，和_join和export一起使用作用于OPERATION上，将其声明为内部函数，不对外暴露作用于变量上，用于入参校验用于数字类型变量，变量>minimum用于数字类型变量，变量<maximum用于数组变量，len(变量)≥minItems用于数组变量，len(变量)≤maxItems用于数组变量，为true时每项值不能重复用于String变量，len(变量)≤maxLength用于数组变量，len(变量) ≤ maxItems用于String变量，校验字符串是否匹配正则同pattern，声明了几种特殊正则枚举作用于OPERATION上，声明API的RBAC权限任意匹配，用户角色与API角色有交集时，可访问（常用）全部匹配，用户角色包含API角色时，可访问非全部匹配，当任意匹配或互斥匹配时，可访问互斥匹配，用户角色与API角色互斥时，可访问作用于MUTATION OPERATION上，指定当前变更为事务操作等待时间超时时间隔离级别作用于对象/数组类型的选择集上，将其拍扁示例用法：info.name用作将参数动态转换成查询条件反向筛选筛选条件筛选字段普通筛选关联筛选筛选类型忽略大小写嵌套条件作用于变量上，根据表达式注入参数，可以从arguments，request.header, request.body, environment获取参数作用于OPERATION上，禁止graphql并行解析作用于标量选择集上，自定义字段，可以在钩子和返回值中看到作用于标量选择集上，根据条件跳过参数填充作用于标量选择集上，并行解析数组提升响应速度作用于标量选择集上，用于提取首个 QueryRaw/ExecuteRaw 响应"
)

var (
	_Directive_ZhCn_map = map[Directive]string{
		0:     _Directive_ZhCn_name[0:72],
		10101: _Directive_ZhCn_name[72:114],
		10102: _Directive_ZhCn_name[114:167],
		10103: _Directive_ZhCn_name[167:235],
		10201: _Directive_ZhCn_name[235:280],
		10202: _Directive_ZhCn_name[280:350],
		10203: _Directive_ZhCn_name[350:457],
		10301: _Directive_ZhCn_name[457:517],
		10401: _Directive_ZhCn_name[517:588],
		10501: _Directive_ZhCn_name[588:657],
		10601: _Directive_ZhCn_name[657:696],
		10602: _Directive_ZhCn_name[696:737],
		10603: _Directive_ZhCn_name[737:778],
		10604: _Directive_ZhCn_name[778:821],
		10605: _Directive_ZhCn_name[821:864],
		10606: _Directive_ZhCn_name[864:916],
		10607: _Directive_ZhCn_name[916:960],
		10608: _Directive_ZhCn_name[960:1005],
		10609: _Directive_ZhCn_name[1005:1059],
		10610: _Directive_ZhCn_name[1059:1105],
		10701: _Directive_ZhCn_name[1105:1151],
		10702: _Directive_ZhCn_name[1151:1226],
		10703: _Directive_ZhCn_name[1226:1283],
		10704: _Directive_ZhCn_name[1283:1346],
		10705: _Directive_ZhCn_name[1346:1406],
		10801: _Directive_ZhCn_name[1406:1472],
		10802: _Directive_ZhCn_name[1472:1484],
		10803: _Directive_ZhCn_name[1484:1496],
		10804: _Directive_ZhCn_name[1496:1508],
		10901: _Directive_ZhCn_name[1508:1566],
		10902: _Directive_ZhCn_name[1566:1590],
		11001: _Directive_ZhCn_name[1590:1632],
		11002: _Directive_ZhCn_name[1632:1644],
		11003: _Directive_ZhCn_name[1644:1656],
		11004: _Directive_ZhCn_name[1656:1668],
		11005: _Directive_ZhCn_name[1668:1680],
		11006: _Directive_ZhCn_name[1680:1692],
		11007: _Directive_ZhCn_name[1692:1704],
		11008: _Directive_ZhCn_name[1704:1719],
		11009: _Directive_ZhCn_name[1719:1731],
		11101: _Directive_ZhCn_name[1731:1856],
		11201: _Directive_ZhCn_name[1856:1905],
		11301: _Directive_ZhCn_name[1905:1989],
		11401: _Directive_ZhCn_name[1989:2049],
		11501: _Directive_ZhCn_name[2049:2115],
		11601: _Directive_ZhCn_name[2115:2190],
	}
)

// _transOne translate one CONST
func (i Directive) _transOne(locale string) string {
	switch locale {
	case "zh_cn":
		if str, ok := _Directive_ZhCn_map[i]; ok {
			return str
		}
		return "Directive[" + locale + "](" + strconv.FormatInt(int64(i), 10) + ")"
	default:
		// Normally unreachable, should not happen but be cautious
		return ""
	}
}

// _Directive_supported All supported locales record
var _Directive_supported = map[string]int{"zh_cn": 0}

// _Directive_defaultLocale default locale
// generated pass by i18n-stringer flag -defaultlocale, Don't assign directly
var _Directive_defaultLocale = "zh_cn"

// _Directive_ctxKey Key from context.Context Value get locale
// generated pass by i18n-stringer flag -ctxkey, Don't assign directly
var _Directive_ctxKey = "i18nLocale"

// WARNING: You should use Trans, Lang, Wrap, WrapWithContext method instead
//   - You should not use this method in an internationalized language environment, as well as method Error.
//   - Because this method always returns the translation value of the default language.
//   - This method implements the fmt.Stringer interface, so that you can output it directly by package fmt,
//   - If you understand the above mechanism then you can use this method with confidence
func (i Directive) String() string {
	return i._trans(_Directive_defaultLocale)
}

// WARNING: You should use Trans, Lang, Wrap, WrapWithContext method instead
//   - You should not use this method in an internationalized language environment, as well as method String.
//   - Because this method always returns the translation value of the default language.
//   - This method implements the error interface, so that you can return the value as an error,
//   - If you understand the above mechanism then you can use this method with confidence
func (i Directive) Error() string {
	return i._trans(_Directive_defaultLocale)
}

// Code get original type uint16 value
func (i Directive) Code() uint16 {
	return uint16(i)
}

// Wrap another error with locale set for i18n TYPE Const
//   - err another error
//   - locale i18n locale name
//   - args optional formatting component
func (i Directive) Wrap(err error, locale string, args ...interface{}) *I18nDirectiveErrorWrap {
	return &I18nDirectiveErrorWrap{err: err, origin: i, locale: locale, args: args}
}

// WrapWithContext wrap another error with context.Context set for i18n TYPE Const
//   - ctx context with Value use Key from _Directive_ctxKey, which pass by i18n-stringer flag -ctxkey
//   - err another error
//   - args optional formatting component
func (i Directive) WrapWithContext(ctx context.Context, err error, args ...interface{}) *I18nDirectiveErrorWrap {
	return &I18nDirectiveErrorWrap{err: err, origin: i, locale: _Directive_localeFromCtxWithFallback(ctx), args: args}
}

// I18nDirectiveErrorWrap type i18n error wrapper
//
//	WARNING
//	This struct ONLY used to wrap the CONST generated by the i18n-stringer tool,
//	Pass easily obtain internationalized translations through Error, String, Translate
//	WARNING
type I18nDirectiveErrorWrap struct {
	err    error         // wrap another error
	origin Directive     // custom shaping type Val
	locale string        // i18n locale set
	args   []interface{} // formatted output replacement component
}

// Translate get translated string
func (e *I18nDirectiveErrorWrap) Translate() string {
	return e.origin.Trans(e.locale, e.args...)
}

// String implement fmt.Stringer, get translated string use Translate
func (e *I18nDirectiveErrorWrap) String() string {
	return e.Translate()
}

// Error struct as error, get typed message wrap with inside error message
//   - this method will be formatted wrap error if exist.
//   - Only for development and debugging, or logging full error message
//   - if you want to get typed message, please use method String or Translate
func (e *I18nDirectiveErrorWrap) Error() string {
	if e.err == nil {
		return e.Translate()
	}
	return fmt.Sprintf("%s (%s)", e.Translate(), e.err.Error())
}

// Format alias for method Error
//   - this method will be formatted wrap error if exist.
//   - Only for development and debugging, or logging full error message
//   - if you want to get typed message, please use method String or Translate
func (e *I18nDirectiveErrorWrap) Format() string {
	return e.Error()
}

// Value get original type value
func (e *I18nDirectiveErrorWrap) Value() Directive {
	return e.origin
}

// Unwrap an error. Get the error inside
func (e *I18nDirectiveErrorWrap) Unwrap() error {
	return e.err
}

// IsLocaleSupport Check if the specified locale is supported
func (i Directive) IsLocaleSupport(locale string) bool {
	return _Directive_isLocaleSupport(locale)
}

// Lang get target translate text use context.Context
//   - ctx  context with Value use Key from _Directive_ctxKey, which pass by i18n-stringer flag -ctxkey
//   - args Optional placeholder replacement value, value type of Directive, or type of string
func (i Directive) Lang(ctx context.Context, args ...interface{}) string {
	return i._trans(_Directive_localeFromCtxWithFallback(ctx), args...)
}

// Trans get target translate text use specified language locale identifier
//   - locale specified language locale identifier, need pass by IsLocaleSupport
//   - args Optional placeholder replacement value, value type of Directive, or type of string
func (i Directive) Trans(locale string, args ...interface{}) string {
	if !_Directive_isLocaleSupport(locale) {
		locale = _Directive_defaultLocale
	}
	return i._trans(locale, args...)
}

func _Directive_isLocaleSupport(locale string) bool {
	_, ok := _Directive_supported[locale]
	return ok
}

// _Directive_localeFromCtxWithFallback retrieves and returns language locale name from context.
// It returns default locale when _Directive_isLocaleSupport is false
func _Directive_localeFromCtxWithFallback(ctx context.Context) string {
	if ctx == nil {
		return _Directive_defaultLocale
	}
	v := ctx.Value(_Directive_ctxKey)
	if v == nil {
		return _Directive_defaultLocale
	}
	if vv, ok := v.(string); ok && _Directive_isLocaleSupport(vv) {
		return vv
	}
	return _Directive_defaultLocale
}

// _trans trustworthy parameters inside method
//   - locale i18n local
//   - args   value type of Directive, or type of string
func (i Directive) _trans(locale string, args ...interface{}) string {
	msg := i._transOne(locale)
	if len(args) > 0 {
		var com []interface{}
		for _, arg := range args {
			if typ, ok := arg.(Directive); ok {
				com = append(com, typ._transOne(locale))
			} else {
				com = append(com, arg) // arg as string scalar
			}
		}
		return fmt.Sprintf(msg, com...)
	}
	return msg
}
