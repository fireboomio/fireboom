// Code generated by "i18n-stringer -type PrismaError -tomlpath prisma_error -defaultlocale zh_cn"; DO NOT EDIT.

package i18n

import (
	"context"
	"fmt"
	"strconv"
)

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the i18n-stringer command to generate them again.
	var x [1]struct{}
	_ = x[PrismaError_P1000-1000]
	_ = x[PrismaError_P1001-1001]
	_ = x[PrismaError_P1002-1002]
	_ = x[PrismaError_P1003-1003]
	_ = x[PrismaError_P1008-1008]
	_ = x[PrismaError_P1009-1009]
	_ = x[PrismaError_P1010-1010]
	_ = x[PrismaError_P1011-1011]
	_ = x[PrismaError_P1012-1012]
	_ = x[PrismaError_P1013-1013]
	_ = x[PrismaError_P1014-1014]
	_ = x[PrismaError_P1015-1015]
	_ = x[PrismaError_P1016-1016]
	_ = x[PrismaError_P1017-1017]
	_ = x[PrismaError_P1018-1018]
	_ = x[PrismaError_P1019-1019]
	_ = x[PrismaError_P2000-2000]
	_ = x[PrismaError_P2001-2001]
	_ = x[PrismaError_P2002-2002]
	_ = x[PrismaError_P2003-2003]
	_ = x[PrismaError_P2004-2004]
	_ = x[PrismaError_P2005-2005]
	_ = x[PrismaError_P2006-2006]
	_ = x[PrismaError_P2007-2007]
	_ = x[PrismaError_P2008-2008]
	_ = x[PrismaError_P2009-2009]
	_ = x[PrismaError_P2010-2010]
	_ = x[PrismaError_P2011-2011]
	_ = x[PrismaError_P2012-2012]
	_ = x[PrismaError_P2013-2013]
	_ = x[PrismaError_P2014-2014]
	_ = x[PrismaError_P2015-2015]
	_ = x[PrismaError_P2016-2016]
	_ = x[PrismaError_P2017-2017]
	_ = x[PrismaError_P2018-2018]
	_ = x[PrismaError_P2019-2019]
	_ = x[PrismaError_P2020-2020]
	_ = x[PrismaError_P2021-2021]
	_ = x[PrismaError_P2022-2022]
	_ = x[PrismaError_P2023-2023]
	_ = x[PrismaError_P2024-2024]
	_ = x[PrismaError_P2025-2025]
	_ = x[PrismaError_P2026-2026]
	_ = x[PrismaError_P2027-2027]
	_ = x[PrismaError_P2028-2028]
	_ = x[PrismaError_P2029-2029]
	_ = x[PrismaError_P2030-2030]
	_ = x[PrismaError_P2031-2031]
	_ = x[PrismaError_P2033-2033]
	_ = x[PrismaError_P2034-2034]
	_ = x[PrismaError_P2035-2035]
	_ = x[PrismaError_P2036-2036]
	_ = x[PrismaError_P2037-2037]
	_ = x[PrismaError_P3000-3000]
	_ = x[PrismaError_P3001-3001]
	_ = x[PrismaError_P3002-3002]
	_ = x[PrismaError_P3003-3003]
	_ = x[PrismaError_P3004-3004]
	_ = x[PrismaError_P3005-3005]
	_ = x[PrismaError_P3006-3006]
	_ = x[PrismaError_P3007-3007]
	_ = x[PrismaError_P3008-3008]
	_ = x[PrismaError_P3009-3009]
	_ = x[PrismaError_P3010-3010]
	_ = x[PrismaError_P3011-3011]
	_ = x[PrismaError_P3012-3012]
	_ = x[PrismaError_P3013-3013]
	_ = x[PrismaError_P3014-3014]
	_ = x[PrismaError_P3015-3015]
	_ = x[PrismaError_P3016-3016]
	_ = x[PrismaError_P3017-3017]
	_ = x[PrismaError_P3018-3018]
	_ = x[PrismaError_P3019-3019]
	_ = x[PrismaError_P3020-3020]
	_ = x[PrismaError_P3021-3021]
	_ = x[PrismaError_P3022-3022]
	_ = x[PrismaError_P4000-4000]
	_ = x[PrismaError_P4001-4001]
	_ = x[PrismaError_P4002-4002]
}

const (
	_PrismaError_ZhCn_name_0 = "针对{database_host}的数据库服务器身份验证失败，为{database_user}提供的数据库凭据无效。请确保在{database_host}上为数据库服务器提供有效的数据库凭据。无法在{database_host}:{database_port}访问数据库服务器，请确保您的数据库服务器在{database_host}:{database_port}运行。{database_host}:{database_port}的数据库服务器已到达，但已过时。请再试一次。请确保您的数据库服务器在{database_host}:{database_port}上运行。{database_file_path}不存在数据库{database_file_name}||数据库{database_name}.{database_schema_name}在{database_host}:{database_port}的数据库服务器上不存在。||数据库{database_name}在{database_host}:{database_port}的数据库服务器上不存在。"
	_PrismaError_ZhCn_name_1 = "{time}之后的操作已过时数据库{database_name}已经存在于{database_host}:{database_port}的数据库服务器上用户{database_user}被拒绝访问数据库{database_name}打开TLS连接时出错: {message}{full_error}提供的数据库字符串无效。{details}模型{model}的基础{kind}不存在。您的Prisma模式正在使用数据库版本不支持的功能。数据库版本: {database_version}。错误: {errors}您的原始查询参数数量不正确。预期: {expected}，实际: {actual}。服务器已关闭连接。{message}{message}"
	_PrismaError_ZhCn_name_2 = "列{column_name}提供的值太长在where条件({model_name}.{argument_name} = {argument_value})中搜索的记录不存在约束{target}出现重复数据字段{field_name}上的外键约束失败数据库上的约束失败: {database_error}存储在数据库中字段{field_name}的值{field_value}对字段类型无效为{model_name}字段{field_name}提供的值{field_value}无效数据验证错误: {database_error}未能在{query_position}解析查询: {query_parsing_error}||kind=EmptySelection<?>在{selectionPath}({outputType.name})上期望至少有1个字段存在，结果是0||kind=InvalidArgumentType<?>在{selectionPath}.{argumentPath}出现无效的参数类型{inferredType},预期是{argument.typeNames}||kind=InvalidArgumentValue<?>在{selectionPath}.{argumentPath}出现无效的参数值，原因: {underlyingError}||kind=SomeFieldsMissing<?>参数{selectionPath}.{argumentPath}缺失(约束{constraints})||kind=TooManyFieldsGiven<?>参数{selectionPath}.{argumentPath}给定过多(约束{constraints})||kind=SelectionSetOnScalar<?>无法在{selectionPath}中的标量字段{fieldName}上进行选择||kind=Union<?>无法将输入值与该字段允许的任何输入类型匹配。解析错误: <each>errors||kind=UnknownArgument<?>参数{selectionPath}.{argumentPath}类型不存在||kind=UnknownInputField<?>输入{selectionPath}.{argumentPath}(inputType.name)不存在||kind=UnknownSelectionField<?>字段{selectionPath}.{outputType.name}不存在||kind=ValueTooLarge<?>无法将参数{selectionPath}.{argumentPath}转换为64位有符号整数。考虑使用BigInt原始查询失败。代码: {code}。消息: {message}{constraint}上的空约束违规在{selectionPath}.{argumentPath}缺少一个必需值缺少{object_name}上字段{field_name}所需的参数{argument_name}您试图进行的更改将违反{model_a_name}和{model_b_name}模型之间的必要关系'{relation_name}'找不到相关记录。{details}查询解释错误。{details}{parent_name}和{child_name}模型之间的关系{relation_name}的记录没有连接找不到所需的连接记录。{details}输入错误。{details}该类型的值超出范围。{details}当前数据库中不存在表{table}当前数据库中不存在{column}列不一致的列数据: {message}从连接池中获取新连接的时已过(当前连接池超时: {timeout}，连接限制: {connection_limit})。(更多信息: http://pris.ly/d/connection-pool)依赖一个或多个的记录找到。{cause}当前数据库提供程序不支持查询使用的功能: {feature}查询执行期间数据库出现多个错误: {errors}事务API错误: {error}查询参数限制超过错误: {message}找不到用于搜索的全文索引，请尝试在您的模式中添加@@fulltext（[Fields...]）Prisma需要执行事务，这需要您的MongoDB服务器作为副本集运行。查看详情: https://pris.ly/d/mongodb-replica-set"
	_PrismaError_ZhCn_name_3 = "查询中使用的数字不适合64位有符号整数。如果您试图存储大整数，请考虑使用BigInt作为字段类型由于写入冲突或死锁，事务失败。请重试您的事务数据库上的断言违规: {database_error}外部连接器错误(id {id})打开的数据库连接太多: {message}"
	_PrismaError_ZhCn_name_4 = "创建数据库失败: {database_error}迁移可能具有破坏性更改和可能的数据丢失: {migration_engine_destructive_details}尝试的迁移被回滚: {database_error}迁移的格式发生了变化，保存的迁移不再有效。要解决这个问题，请按照以下步骤操作: https://pris.ly/d/migrate{database_name}数据库是一个系统数据库，它不应该被棱镜迁移所更改。请连接到另一个数据库。数据库模式不是空的。阅读更多关于如何基线现有生产数据库的信息: https://pris.ly/d/migrate-baseline迁移{migration_name}未能干净地应用于影子数据库。{error_code}错误: {inner_error}一些请求的预览功能尚未在模式引擎中被允许。在使用迁移之前，请将它们从数据模型中删除。（已阻止: {list_of_blocked_features}）迁移{migration_name}已记录为数据库中的应用。迁移在目标数据库中发现失败的迁移，新的迁移将不会应用。阅读更多关于如何解决生产数据库中的迁移问题的信息: https://pris.ly/d/migrate-resolve。{details}迁移的名字太长了。它不得超过200个字符（字节）。迁移{migration_name}无法回滚，因为它从未应用于数据库。提示: 你传递了整个迁移名称吗？（例如: \"20201207184859_initial_migration\"）迁移{migration_name}无法回滚，因为它没有处于失败状态。迁移中不再支持数据源提供商阵列。请将您的数据源更改为使用单个提供商。更多信息请访问https://pris.ly/multi-provider-deprecationPrisma Migrate无法创建影子数据库。请确保数据库用户有权创建数据库。在https://pris.ly/d/migrate-shadow上阅读更多关于影子数据库（和变通办法）的信息。原始错误: {error_code}({inner_error})无法在{migration_file_path}找到迁移文件。请删除目录或恢复迁移文件。数据库重置的回退方法失败，这意味着Migrate无法完全清理数据库。原始错误: {error_code}({inner_error})找不到迁移{migration_name}。请确保迁移存在，并包括目录的整个名称。（例如: \"20201207184859_initial_migration\"）迁移未能适用。在恢复错误之前，无法应用新的迁移。阅读更多关于如何解决生产数据库中的迁移问题的信息: https://pris.ly/d/migrate-resolve。迁移名称: {migration_name}。数据库错误代码: {database_error_code}。数据库错误: {database_error}您的模式中指定的数据源提供程序{provider}与migration_lock.toml中指定的数据源提供程序{provider}不匹配，{expected_provider}。请删除您当前的迁移目录，并使用prisma migrate dev开始新的迁移历史记录。阅读更多: https://pris.ly/d/migrate-provider-switch在Azure SQL上禁用了自动创建阴影数据库。请使用shadowDatabaseUrl数据源属性设置阴影数据库。阅读文档页面了解更多详情: https://pris.ly/d/migrate-shadow无法在此数据库上创建外国密钥。了解更多关于如何处理这个问题: https://pris.ly/d/migrate-no-foreign-keys在此数据库上禁用直接执行DDL（数据定义语言）SQL语句。请在此处阅读更多有关如何处理此操作的信息: https://pris.ly/d/migrate-no-direct-ddl"
	_PrismaError_ZhCn_name_5 = "内省操作未能生成模式文件: {introspection_error}内省的数据库是空的。内省数据库的模式不一致: {explanation}"
)

var (
	_PrismaError_ZhCn_index_0 = [...]uint16{0, 198, 341, 517, 790}
	_PrismaError_ZhCn_index_1 = [...]uint16{0, 30, 124, 184, 219, 231, 276, 316, 436, 518, 545, 554, 563}
	_PrismaError_ZhCn_index_2 = [...]uint16{0, 34, 124, 156, 198, 243, 322, 386, 422, 482, 1591, 1646, 1679, 1733, 1803, 1911, 1944, 1974, 2059, 2101, 2125, 2164, 2201, 2239, 2271, 2433, 2479, 2547, 2602, 2626, 2667, 2766, 2899}
	_PrismaError_ZhCn_index_3 = [...]uint16{0, 128, 194, 239, 269, 310}
	_PrismaError_ZhCn_index_4 = [...]uint16{0, 39, 136, 178, 319, 442, 568, 665, 834, 892, 1092, 1161, 1326, 1399, 1564, 1801, 1891, 2020, 2159, 2454, 2759, 2948, 3078, 3254}
	_PrismaError_ZhCn_index_5 = [...]uint8{0, 59, 89, 137}
)

// _transOne translate one CONST
func (i PrismaError) _transOne(locale string) string {
	switch locale {
	case "zh_cn":
		switch {
		case 1000 <= i && i <= 1003:
			i -= 1000
			return _PrismaError_ZhCn_name_0[_PrismaError_ZhCn_index_0[i]:_PrismaError_ZhCn_index_0[i+1]]
		case 1008 <= i && i <= 1019:
			i -= 1008
			return _PrismaError_ZhCn_name_1[_PrismaError_ZhCn_index_1[i]:_PrismaError_ZhCn_index_1[i+1]]
		case 2000 <= i && i <= 2031:
			i -= 2000
			return _PrismaError_ZhCn_name_2[_PrismaError_ZhCn_index_2[i]:_PrismaError_ZhCn_index_2[i+1]]
		case 2033 <= i && i <= 2037:
			i -= 2033
			return _PrismaError_ZhCn_name_3[_PrismaError_ZhCn_index_3[i]:_PrismaError_ZhCn_index_3[i+1]]
		case 3000 <= i && i <= 3022:
			i -= 3000
			return _PrismaError_ZhCn_name_4[_PrismaError_ZhCn_index_4[i]:_PrismaError_ZhCn_index_4[i+1]]
		case 4000 <= i && i <= 4002:
			i -= 4000
			return _PrismaError_ZhCn_name_5[_PrismaError_ZhCn_index_5[i]:_PrismaError_ZhCn_index_5[i+1]]
		default:
			return "PrismaError[" + locale + "](" + strconv.FormatInt(int64(i), 10) + ")"
		}
	default:
		// Normally unreachable, should not happen but be cautious
		return ""
	}
}

// _PrismaError_supported All supported locales record
var _PrismaError_supported = map[string]int{"zh_cn": 0}

// _PrismaError_defaultLocale default locale
// generated pass by i18n-stringer flag -defaultlocale, Don't assign directly
var _PrismaError_defaultLocale = "zh_cn"

// _PrismaError_ctxKey Key from context.Context Value get locale
// generated pass by i18n-stringer flag -ctxkey, Don't assign directly
var _PrismaError_ctxKey = "i18nLocale"

// WARNING: You should use Trans, Lang, Wrap, WrapWithContext method instead
//   - You should not use this method in an internationalized language environment, as well as method Error.
//   - Because this method always returns the translation value of the default language.
//   - This method implements the fmt.Stringer interface, so that you can output it directly by package fmt,
//   - If you understand the above mechanism then you can use this method with confidence
func (i PrismaError) String() string {
	return i._trans(_PrismaError_defaultLocale)
}

// WARNING: You should use Trans, Lang, Wrap, WrapWithContext method instead
//   - You should not use this method in an internationalized language environment, as well as method String.
//   - Because this method always returns the translation value of the default language.
//   - This method implements the error interface, so that you can return the value as an error,
//   - If you understand the above mechanism then you can use this method with confidence
func (i PrismaError) Error() string {
	return i._trans(_PrismaError_defaultLocale)
}

// Code get original type uint16 value
func (i PrismaError) Code() uint16 {
	return uint16(i)
}

// Wrap another error with locale set for i18n TYPE Const
//   - err another error
//   - locale i18n locale name
//   - args optional formatting component
func (i PrismaError) Wrap(err error, locale string, args ...interface{}) *I18nPrismaErrorErrorWrap {
	return &I18nPrismaErrorErrorWrap{err: err, origin: i, locale: locale, args: args}
}

// WrapWithContext wrap another error with context.Context set for i18n TYPE Const
//   - ctx context with Value use Key from _PrismaError_ctxKey, which pass by i18n-stringer flag -ctxkey
//   - err another error
//   - args optional formatting component
func (i PrismaError) WrapWithContext(ctx context.Context, err error, args ...interface{}) *I18nPrismaErrorErrorWrap {
	return &I18nPrismaErrorErrorWrap{err: err, origin: i, locale: _PrismaError_localeFromCtxWithFallback(ctx), args: args}
}

// I18nPrismaErrorErrorWrap type i18n error wrapper
//
//	WARNING
//	This struct ONLY used to wrap the CONST generated by the i18n-stringer tool,
//	Pass easily obtain internationalized translations through Error, String, Translate
//	WARNING
type I18nPrismaErrorErrorWrap struct {
	err    error         // wrap another error
	origin PrismaError   // custom shaping type Val
	locale string        // i18n locale set
	args   []interface{} // formatted output replacement component
}

// Translate get translated string
func (e *I18nPrismaErrorErrorWrap) Translate() string {
	return e.origin.Trans(e.locale, e.args...)
}

// String implement fmt.Stringer, get translated string use Translate
func (e *I18nPrismaErrorErrorWrap) String() string {
	return e.Translate()
}

// Error struct as error, get typed message wrap with inside error message
//   - this method will be formatted wrap error if exist.
//   - Only for development and debugging, or logging full error message
//   - if you want to get typed message, please use method String or Translate
func (e *I18nPrismaErrorErrorWrap) Error() string {
	if e.err == nil {
		return e.Translate()
	}
	return fmt.Sprintf("%s (%s)", e.Translate(), e.err.Error())
}

// Format alias for method Error
//   - this method will be formatted wrap error if exist.
//   - Only for development and debugging, or logging full error message
//   - if you want to get typed message, please use method String or Translate
func (e *I18nPrismaErrorErrorWrap) Format() string {
	return e.Error()
}

// Value get original type value
func (e *I18nPrismaErrorErrorWrap) Value() PrismaError {
	return e.origin
}

// Unwrap an error. Get the error inside
func (e *I18nPrismaErrorErrorWrap) Unwrap() error {
	return e.err
}

// IsLocaleSupport Check if the specified locale is supported
func (i PrismaError) IsLocaleSupport(locale string) bool {
	return _PrismaError_isLocaleSupport(locale)
}

// Lang get target translate text use context.Context
//   - ctx  context with Value use Key from _PrismaError_ctxKey, which pass by i18n-stringer flag -ctxkey
//   - args Optional placeholder replacement value, value type of PrismaError, or type of string
func (i PrismaError) Lang(ctx context.Context, args ...interface{}) string {
	return i._trans(_PrismaError_localeFromCtxWithFallback(ctx), args...)
}

// Trans get target translate text use specified language locale identifier
//   - locale specified language locale identifier, need pass by IsLocaleSupport
//   - args Optional placeholder replacement value, value type of PrismaError, or type of string
func (i PrismaError) Trans(locale string, args ...interface{}) string {
	if !_PrismaError_isLocaleSupport(locale) {
		locale = _PrismaError_defaultLocale
	}
	return i._trans(locale, args...)
}

func _PrismaError_isLocaleSupport(locale string) bool {
	_, ok := _PrismaError_supported[locale]
	return ok
}

// _PrismaError_localeFromCtxWithFallback retrieves and returns language locale name from context.
// It returns default locale when _PrismaError_isLocaleSupport is false
func _PrismaError_localeFromCtxWithFallback(ctx context.Context) string {
	if ctx == nil {
		return _PrismaError_defaultLocale
	}
	v := ctx.Value(_PrismaError_ctxKey)
	if v == nil {
		return _PrismaError_defaultLocale
	}
	if vv, ok := v.(string); ok && _PrismaError_isLocaleSupport(vv) {
		return vv
	}
	return _PrismaError_defaultLocale
}

// _trans trustworthy parameters inside method
//   - locale i18n local
//   - args   value type of PrismaError, or type of string
func (i PrismaError) _trans(locale string, args ...interface{}) string {
	msg := i._transOne(locale)
	if len(args) > 0 {
		var com []interface{}
		for _, arg := range args {
			if typ, ok := arg.(PrismaError); ok {
				com = append(com, typ._transOne(locale))
			} else {
				com = append(com, arg) // arg as string scalar
			}
		}
		return fmt.Sprintf(msg, com...)
	}
	return msg
}
