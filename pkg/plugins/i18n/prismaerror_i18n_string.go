// Code generated by "i18n-stringer -type PrismaError -tomlpath prisma_error -defaultlocale zh_cn"; DO NOT EDIT.

package i18n

import (
	"context"
	"fmt"
	"strconv"
)

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the i18n-stringer command to generate them again.
	var x [1]struct{}
	_ = x[PrismaError_P2000-2000]
	_ = x[PrismaError_P2001-2001]
	_ = x[PrismaError_P2002-2002]
	_ = x[PrismaError_P2003-2003]
	_ = x[PrismaError_P2004-2004]
	_ = x[PrismaError_P2005-2005]
	_ = x[PrismaError_P2006-2006]
	_ = x[PrismaError_P2007-2007]
	_ = x[PrismaError_P2008-2008]
	_ = x[PrismaError_P2009-2009]
	_ = x[PrismaError_P2010-2010]
	_ = x[PrismaError_P2011-2011]
	_ = x[PrismaError_P2012-2012]
	_ = x[PrismaError_P2013-2013]
	_ = x[PrismaError_P2014-2014]
	_ = x[PrismaError_P2015-2015]
	_ = x[PrismaError_P2016-2016]
	_ = x[PrismaError_P2017-2017]
	_ = x[PrismaError_P2018-2018]
	_ = x[PrismaError_P2019-2019]
	_ = x[PrismaError_P2020-2020]
	_ = x[PrismaError_P2021-2021]
	_ = x[PrismaError_P2022-2022]
	_ = x[PrismaError_P2023-2023]
	_ = x[PrismaError_P2024-2024]
	_ = x[PrismaError_P2025-2025]
	_ = x[PrismaError_P2026-2026]
	_ = x[PrismaError_P2027-2027]
	_ = x[PrismaError_P2028-2028]
	_ = x[PrismaError_P2029-2029]
	_ = x[PrismaError_P2030-2030]
	_ = x[PrismaError_P2031-2031]
	_ = x[PrismaError_P2033-2032]
	_ = x[PrismaError_P2034-2033]
	_ = x[PrismaError_P2035-2034]
	_ = x[PrismaError_P2036-2035]
	_ = x[PrismaError_P2037-2036]
}

const (
	_PrismaError_ZhCn_name = "列{column_name}提供的值太长在where条件({model_name}.{argument_name} = {argument_value})中搜索的记录不存在约束{target}出现重复数据字段{field_name}上的外键约束失败数据库上的约束失败: {database_error}存储在数据库中字段{field_name}的值{field_value}对字段类型无效为{model_name}字段{field_name}提供的值{field_value}无效数据验证错误: {database_error}未能在{query_position}解析查询: {query_parsing_error}无法在{query_position}验证查询: {query_validation_error}原始查询失败。代码: {code}。消息: {message}{constraint}上的空约束违规在{path}缺少一个必需值缺少{object_name}上字段{field_name}所需的参数{argument_name}您试图进行的更改将违反{model_a_name}和{model_b_name}模型之间的必要关系'{relation_name}'找不到相关记录。{details}查询解释错误。{details}{parent_name}和{child_name}模型之间的关系{relation_name}的记录没有连接找不到所需的连接记录。{details}输入错误。{details}该类型的值超出范围。{details}当前数据库中不存在表{table}当前数据库中不存在{column}列不一致的列数据: {message}从连接池中获取新连接的时已过(当前连接池超时: {timeout}，连接限制: {connection_limit})。(更多信息: http://pris.ly/d/connection-pool)依赖一个或多个的记录找到。{cause}当前数据库提供程序不支持查询使用的功能: {feature}查询执行期间数据库出现多个错误: {errors}事务API错误: {error}查询参数限制超过错误: {message}找不到用于搜索的全文索引，请尝试在您的模式中添加@@fulltext（[Fields...]）Prisma需要执行事务，这需要您的MongoDB服务器作为副本集运行。查看详情: https://pris.ly/d/mongodb-replica-set查询中使用的数字不适合64位有符号整数。如果您试图存储大整数，请考虑使用BigInt作为字段类型由于写入冲突或死锁，事务失败。请重试您的事务数据库上的断言违规: {database_error}外部连接器错误(id {id})打开的数据库连接太多: {message}"
)

var (
	_PrismaError_ZhCn_index = [...]uint16{0, 34, 124, 156, 198, 243, 322, 386, 422, 482, 545, 600, 633, 663, 733, 841, 874, 904, 989, 1031, 1055, 1094, 1131, 1169, 1201, 1363, 1409, 1477, 1532, 1556, 1597, 1696, 1829, 1957, 2023, 2068, 2098, 2139}
)

// _transOne translate one CONST
func (i PrismaError) _transOne(locale string) string {
	i -= 2000
	if i >= PrismaError(len(_PrismaError_ZhCn_index)-1) {
		return "PrismaError[" + locale + "](" + strconv.FormatInt(int64(i), 10) + ")"
	}

	switch locale {
	case "zh_cn":
		return _PrismaError_ZhCn_name[_PrismaError_ZhCn_index[i]:_PrismaError_ZhCn_index[i+1]]
	default:
		// Normally unreachable, should not happen but be cautious
		return ""
	}
}

// _PrismaError_supported All supported locales record
var _PrismaError_supported = map[string]int{"zh_cn": 0}

// _PrismaError_defaultLocale default locale
// generated pass by i18n-stringer flag -defaultlocale, Don't assign directly
var _PrismaError_defaultLocale = "zh_cn"

// _PrismaError_ctxKey Key from context.Context Value get locale
// generated pass by i18n-stringer flag -ctxkey, Don't assign directly
var _PrismaError_ctxKey = "i18nLocale"

// WARNING: You should use Trans, Lang, Wrap, WrapWithContext method instead
//   - You should not use this method in an internationalized language environment, as well as method Error.
//   - Because this method always returns the translation value of the default language.
//   - This method implements the fmt.Stringer interface, so that you can output it directly by package fmt,
//   - If you understand the above mechanism then you can use this method with confidence
func (i PrismaError) String() string {
	return i._trans(_PrismaError_defaultLocale)
}

// WARNING: You should use Trans, Lang, Wrap, WrapWithContext method instead
//   - You should not use this method in an internationalized language environment, as well as method String.
//   - Because this method always returns the translation value of the default language.
//   - This method implements the error interface, so that you can return the value as an error,
//   - If you understand the above mechanism then you can use this method with confidence
func (i PrismaError) Error() string {
	return i._trans(_PrismaError_defaultLocale)
}

// Code get original type uint16 value
func (i PrismaError) Code() uint16 {
	return uint16(i)
}

// Wrap another error with locale set for i18n TYPE Const
//   - err another error
//   - locale i18n locale name
//   - args optional formatting component
func (i PrismaError) Wrap(err error, locale string, args ...interface{}) *I18nPrismaErrorErrorWrap {
	return &I18nPrismaErrorErrorWrap{err: err, origin: i, locale: locale, args: args}
}

// WrapWithContext wrap another error with context.Context set for i18n TYPE Const
//   - ctx context with Value use Key from _PrismaError_ctxKey, which pass by i18n-stringer flag -ctxkey
//   - err another error
//   - args optional formatting component
func (i PrismaError) WrapWithContext(ctx context.Context, err error, args ...interface{}) *I18nPrismaErrorErrorWrap {
	return &I18nPrismaErrorErrorWrap{err: err, origin: i, locale: _PrismaError_localeFromCtxWithFallback(ctx), args: args}
}

// I18nPrismaErrorErrorWrap type i18n error wrapper
//
//	WARNING
//	This struct ONLY used to wrap the CONST generated by the i18n-stringer tool,
//	Pass easily obtain internationalized translations through Error, String, Translate
//	WARNING
type I18nPrismaErrorErrorWrap struct {
	err    error         // wrap another error
	origin PrismaError   // custom shaping type Val
	locale string        // i18n locale set
	args   []interface{} // formatted output replacement component
}

// Translate get translated string
func (e *I18nPrismaErrorErrorWrap) Translate() string {
	return e.origin.Trans(e.locale, e.args...)
}

// String implement fmt.Stringer, get translated string use Translate
func (e *I18nPrismaErrorErrorWrap) String() string {
	return e.Translate()
}

// Error struct as error, get typed message wrap with inside error message
//   - this method will be formatted wrap error if exist.
//   - Only for development and debugging, or logging full error message
//   - if you want to get typed message, please use method String or Translate
func (e *I18nPrismaErrorErrorWrap) Error() string {
	if e.err == nil {
		return e.Translate()
	}
	return fmt.Sprintf("%s (%s)", e.Translate(), e.err.Error())
}

// Format alias for method Error
//   - this method will be formatted wrap error if exist.
//   - Only for development and debugging, or logging full error message
//   - if you want to get typed message, please use method String or Translate
func (e *I18nPrismaErrorErrorWrap) Format() string {
	return e.Error()
}

// Value get original type value
func (e *I18nPrismaErrorErrorWrap) Value() PrismaError {
	return e.origin
}

// Unwrap an error. Get the error inside
func (e *I18nPrismaErrorErrorWrap) Unwrap() error {
	return e.err
}

// IsLocaleSupport Check if the specified locale is supported
func (i PrismaError) IsLocaleSupport(locale string) bool {
	return _PrismaError_isLocaleSupport(locale)
}

// Lang get target translate text use context.Context
//   - ctx  context with Value use Key from _PrismaError_ctxKey, which pass by i18n-stringer flag -ctxkey
//   - args Optional placeholder replacement value, value type of PrismaError, or type of string
func (i PrismaError) Lang(ctx context.Context, args ...interface{}) string {
	return i._trans(_PrismaError_localeFromCtxWithFallback(ctx), args...)
}

// Trans get target translate text use specified language locale identifier
//   - locale specified language locale identifier, need pass by IsLocaleSupport
//   - args Optional placeholder replacement value, value type of PrismaError, or type of string
func (i PrismaError) Trans(locale string, args ...interface{}) string {
	if !_PrismaError_isLocaleSupport(locale) {
		locale = _PrismaError_defaultLocale
	}
	return i._trans(locale, args...)
}

func _PrismaError_isLocaleSupport(locale string) bool {
	_, ok := _PrismaError_supported[locale]
	return ok
}

// _PrismaError_localeFromCtxWithFallback retrieves and returns language locale name from context.
// It returns default locale when _PrismaError_isLocaleSupport is false
func _PrismaError_localeFromCtxWithFallback(ctx context.Context) string {
	if ctx == nil {
		return _PrismaError_defaultLocale
	}
	v := ctx.Value(_PrismaError_ctxKey)
	if v == nil {
		return _PrismaError_defaultLocale
	}
	if vv, ok := v.(string); ok && _PrismaError_isLocaleSupport(vv) {
		return vv
	}
	return _PrismaError_defaultLocale
}

// _trans trustworthy parameters inside method
//   - locale i18n local
//   - args   value type of PrismaError, or type of string
func (i PrismaError) _trans(locale string, args ...interface{}) string {
	msg := i._transOne(locale)
	if len(args) > 0 {
		var com []interface{}
		for _, arg := range args {
			if typ, ok := arg.(PrismaError); ok {
				com = append(com, typ._transOne(locale))
			} else {
				com = append(com, arg) // arg as string scalar
			}
		}
		return fmt.Sprintf(msg, com...)
	}
	return msg
}
